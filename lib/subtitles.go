package lib

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"videotranscript-app/models"
)

// SubtitleFormat represents different subtitle formats
type SubtitleFormat string

const (
	FormatSRT SubtitleFormat = "srt"
	FormatVTT SubtitleFormat = "vtt"
)

// GenerateSubtitles creates subtitle files in SRT and VTT formats
func GenerateSubtitles(segments []models.Segment, outputDir, baseName string) (string, string, error) {
	srtPath := filepath.Join(outputDir, baseName+".srt")
	vttPath := filepath.Join(outputDir, baseName+".vtt")

	// Generate SRT file
	if err := generateSRT(segments, srtPath); err != nil {
		return "", "", fmt.Errorf("failed to generate SRT: %w", err)
	}

	// Generate VTT file
	if err := generateVTT(segments, vttPath); err != nil {
		return "", "", fmt.Errorf("failed to generate VTT: %w", err)
	}

	return srtPath, vttPath, nil
}

// generateSRT creates an SRT subtitle file
func generateSRT(segments []models.Segment, outputPath string) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	for i, segment := range segments {
		// SRT format: sequence number, timestamps, text, blank line
		fmt.Fprintf(file, "%d\n", i+1)
		fmt.Fprintf(file, "%s --> %s\n", formatSRTTime(segment.Start), formatSRTTime(segment.End))
		fmt.Fprintf(file, "%s\n\n", segment.Text)
	}

	return nil
}

// generateVTT creates a WebVTT subtitle file
func generateVTT(segments []models.Segment, outputPath string) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	// VTT header
	fmt.Fprintf(file, "WEBVTT\n\n")

	for _, segment := range segments {
		// VTT format: timestamps, text, blank line
		fmt.Fprintf(file, "%s --> %s\n", formatVTTTime(segment.Start), formatVTTTime(segment.End))
		fmt.Fprintf(file, "%s\n\n", segment.Text)
	}

	return nil
}

// formatSRTTime formats seconds to SRT time format (HH:MM:SS,mmm)
func formatSRTTime(seconds float64) string {
	duration := time.Duration(seconds * float64(time.Second))
	hours := int(duration.Hours())
	minutes := int(duration.Minutes()) % 60
	secs := int(duration.Seconds()) % 60
	millis := int(duration.Milliseconds()) % 1000

	return fmt.Sprintf("%02d:%02d:%02d,%03d", hours, minutes, secs, millis)
}

// formatVTTTime formats seconds to VTT time format (HH:MM:SS.mmm)
func formatVTTTime(seconds float64) string {
	duration := time.Duration(seconds * float64(time.Second))
	hours := int(duration.Hours())
	minutes := int(duration.Minutes()) % 60
	secs := int(duration.Seconds()) % 60
	millis := int(duration.Milliseconds()) % 1000

	return fmt.Sprintf("%02d:%02d:%02d.%03d", hours, minutes, secs, millis)
}

// LoadSubtitlesFromWhisperOutput loads subtitle files generated by Whisper
func LoadSubtitlesFromWhisperOutput(outputDir, baseName string) (string, string, error) {
	// Whisper generates files with the audio filename as base
	srtPath := filepath.Join(outputDir, baseName+".srt")
	vttPath := filepath.Join(outputDir, baseName+".vtt")

	// Check if files exist
	srtExists := fileExists(srtPath)
	vttExists := fileExists(vttPath)

	if !srtExists && !vttExists {
		return "", "", fmt.Errorf("no subtitle files found in %s", outputDir)
	}

	srtResult := ""
	vttResult := ""

	if srtExists {
		srtResult = srtPath
	}
	if vttExists {
		vttResult = vttPath
	}

	return srtResult, vttResult, nil
}

// fileExists checks if a file exists
func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	return !os.IsNotExist(err)
}

// ConvertSegmentsToSubtitles creates subtitle content from segments
func ConvertSegmentsToSubtitles(segments []models.Segment, format SubtitleFormat) string {
	var builder strings.Builder

	switch format {
	case FormatSRT:
		for i, segment := range segments {
			builder.WriteString(fmt.Sprintf("%d\n", i+1))
			builder.WriteString(fmt.Sprintf("%s --> %s\n", formatSRTTime(segment.Start), formatSRTTime(segment.End)))
			builder.WriteString(fmt.Sprintf("%s\n\n", segment.Text))
		}
	case FormatVTT:
		builder.WriteString("WEBVTT\n\n")
		for _, segment := range segments {
			builder.WriteString(fmt.Sprintf("%s --> %s\n", formatVTTTime(segment.Start), formatVTTTime(segment.End)))
			builder.WriteString(fmt.Sprintf("%s\n\n", segment.Text))
		}
	}

	return builder.String()
}

// SubtitleMetadata contains information about generated subtitle files
type SubtitleMetadata struct {
	SRTPath      string `json:"srt_path,omitempty"`
	VTTPath      string `json:"vtt_path,omitempty"`
	SegmentCount int    `json:"segment_count"`
	Duration     float64 `json:"duration_seconds"`
	Language     string `json:"language"`
	Format       string `json:"format"`
}

// GetSubtitleMetadata returns metadata about the generated subtitles
func GetSubtitleMetadata(segments []models.Segment, srtPath, vttPath string) SubtitleMetadata {
	duration := 0.0
	if len(segments) > 0 {
		duration = segments[len(segments)-1].End
	}

	return SubtitleMetadata{
		SRTPath:      srtPath,
		VTTPath:      vttPath,
		SegmentCount: len(segments),
		Duration:     duration,
		Language:     "en",
		Format:       "timestamped",
	}
}